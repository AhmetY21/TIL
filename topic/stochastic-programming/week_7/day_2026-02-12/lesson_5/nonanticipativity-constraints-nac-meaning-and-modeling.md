---
title: "Nonanticipativity Constraints (NAC): meaning and modeling"
date: "2026-02-12"
week: 7
lesson: 5
slug: "nonanticipativity-constraints-nac-meaning-and-modeling"
---

# Topic: Nonanticipativity Constraints (NAC): meaning and modeling

## 1) Formal definition (what is it, and how can we use it?)

Nonanticipativity constraints (NACs) are a fundamental concept in stochastic programming. They enforce the principle that decisions made *before* knowing the realization of uncertain parameters must be the same across all scenarios that are indistinguishable up to that point in time. In other words, you cannot use information you don't have yet to make decisions.

Formally, in a multi-stage stochastic programming problem, let:

*   `x_t(ω)` represent the decision vector at stage `t` under scenario `ω`.
*   `F_t` be the information available up to stage `t`. This could be represented as a sigma-algebra, meaning we can observe the outcome of some random variables.

Then, NACs require that:

`x_t(ω) = x_t(ω')`  for all `ω, ω'` such that `ω` and `ω'` are indistinguishable given `F_t`.  This means `ω` and `ω'` have the same history up to stage `t`.

In simpler terms:

*   **Meaning:** Decisions in early stages cannot depend on future information.
*   **Use:** NACs ensure that the solution is *implementable*. Without them, the optimal solution might involve making different decisions at the same stage based on different hypothetical future outcomes that haven't happened yet. This is unrealistic. They constrain the decision variables in different scenarios to have the same value when they are supposed to be based on the same information.

NACs are often implemented by explicitly equating decision variables in different scenarios up to the time at which the uncertainty is realized. For example, if the first stage decision is made before any uncertainty is revealed, then the first stage decision variable must be the same for all scenarios.

## 2) Application scenario

Consider a power generation company that needs to decide how much to invest in different types of power plants (e.g., coal, solar, wind) over a planning horizon of several years. The future electricity demand and fuel prices are uncertain. This is a stochastic programming problem.

*   **Stage 1 (Year 0):** Invest in power plants.
*   **Stage 2 (Year 1-5):** Operate the plants, buy fuel, and meet electricity demand.

Let `x` be the vector of investment decisions (e.g., capacity of each type of power plant) and `y_t(ω)` be the vector of operating decisions at year `t` under scenario `ω` (e.g., amount of electricity generated by each plant, amount of fuel purchased).

Without NACs, the investment decision `x` could be different for each scenario.  This would mean the company builds different power plants in Year 0 depending on what electricity demand will be like in 5 years, even though they don't *know* the demand in 5 years at Year 0. This is impossible.

To impose NACs, we would require:

`x(ω) = x(ω')  for all scenarios ω, ω'`

This means the investment decision (which is made before any uncertainty is revealed) is the same across all scenarios. This ensures the solution is implementable - the company makes a single investment decision in Year 0 based on the information available at that time. The second-stage operational decisions `y_t(ω)` can vary across scenarios, as they are made after the uncertainty has been partially revealed and new information is available.

## 3) Python method (if possible)

The implementation depends on the specific stochastic programming solver and modeling environment. Here's an example using the `pyomo` library and assuming a scenario-based formulation:

```python
import pyomo.environ as pyo

def create_model(scenarios):
    model = pyo.ConcreteModel()

    # Scenario set
    model.S = pyo.Set(initialize=scenarios)

    # Decision Variables (example: amount to invest in a certain technology)
    model.x = pyo.Var(domain=pyo.NonNegativeReals) # First stage decision: investment

    model.y = pyo.Var(model.S, domain=pyo.NonNegativeReals) #Second stage decision: operational
    # Objective Function (example: minimizing total cost across all scenarios)
    def objective_rule(model):
        return sum(model.y[s] for s in model.S) + model.x # Simplified.  Should involve scenario probabilities.
    model.objective = pyo.Objective(rule=objective_rule, sense=pyo.MINIMIZE)

    # Nonanticipativity Constraint
    def nac_rule(model):
        # Ensure the investment decision is the same for all scenarios.
        # Choose an arbitrary scenario as the reference point.
        first_scenario = next(iter(model.S))  #Get first element
        for s in model.S:
            if s != first_scenario:
                yield model.x == model.x  #  A bit redundant in this simple example, but shows concept
                # More commonly, there might be scenario specific costs/constraints that influence x's definition but are equivalent due to NAC.
    model.nac_constraint = pyo.ConstraintList(rule=nac_rule) #constraint list to handle multiple constraints

    # Constraints (example: demand must be met in each scenario)
    def demand_rule(model, s):
      #model.y[s] >= demand[s] # Replace with actual demand calculation
      return pyo.Constraint.Skip  #dummy, for demonstration purposes
    model.demand_constraint = pyo.Constraint(model.S, rule=demand_rule)
    return model

# Example Usage:
scenarios = ['scenario_1', 'scenario_2', 'scenario_3']
model = create_model(scenarios)

# Solve the model (replace with your preferred solver and settings)
solver = pyo.SolverFactory('glpk')  # or e.g., 'cplex'
results = solver.solve(model)

# Print results (example: optimal investment level)
print(f"Optimal investment: {model.x.value}")
for s in scenarios:
  print(f"Optimal operational decision in {s}: {model.y[s].value}")

```

**Explanation:**

1.  **`model.x`:** This is the first-stage decision variable (e.g., investment), which must be the same across all scenarios.
2.  **`model.S`:** This is the set of scenarios.
3.  **`nac_rule`:** This function defines the nonanticipativity constraint.  It iterates through the scenarios and ensures that the investment decision `model.x` is equal to itself. This is a simplistic example; in a real-world problem, `x`'s definition might depend on scenario-specific information, but the NAC would ensure its value is consistent.  The first scenario is used as a reference point.
4.  **`pyo.ConstraintList`**: Use a constraint list to add multiple NACs if you have multiple first-stage variables.
5. The solver will throw an error if infeasibility is detected due to conflicting NACs.

**Important notes:**

*   This is a simplified example.  In more complex models, the NACs may involve more complex relationships between variables and across scenarios.
*   The efficiency of the solution depends on the specific stochastic programming solver and the structure of the problem.
*   In scenarios with more complex information revelation structures (e.g., decisions made at multiple points in time), the NACs will need to be adapted to reflect the information available at each decision point. You would equate the variables only across scenarios that are indistinguishable *up to that point in time*.
*  The solver choice (glpk, cplex, gurobi) is crucial for large and complex problems.
*  The objective function should include scenario probabilities.

## 4) Follow-up question

How do you handle nonanticipativity constraints when using decomposition methods like L-shaped method or progressive hedging to solve stochastic programs? How do the NACs influence the master and subproblem formulations in these approaches?