<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Cross-Fitting and Orthogonalization</title>
  <script>
    if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  </script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.6;
      max-width: 900px;
      margin: 0 auto;
      padding: 24px;
      color: #111827;
      background: #ffffff;
    }
    h1, h2, h3 { color: #111827; }
    a { color: #2563eb; text-decoration: none; }
    a:hover { text-decoration: underline; }
    code { background-color: #f3f4f6; padding: 2px 6px; border-radius: 6px; }
    pre { background-color: #0b1020; color: #e5e7eb; padding: 16px; border-radius: 10px; overflow-x: auto; }
    pre code { background: transparent; padding: 0; }
    blockquote { border-left: 4px solid #e5e7eb; margin: 0; padding-left: 16px; color: #4b5563; }
    table { width: 100%; border-collapse: collapse; margin: 16px 0; }
    th, td { border: 1px solid #e5e7eb; padding: 8px; text-align: left; }
    th { background: #f9fafb; }
    hr { border: none; border-top: 1px solid #e5e7eb; margin: 24px 0; }

    .page-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid #e5e7eb;
    }
    .back-link {
      font-weight: 600;
      text-decoration: none;
    }
    .back-link:hover {
      text-decoration: underline;
    }

    .theme-toggle {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 1.5rem;
      padding: 8px;
      border-radius: 50%;
      transition: background 0.2s;
    }
    .theme-toggle:hover {
      background: rgba(0,0,0,0.05);
    }
    .dark .theme-toggle:hover {
      background: rgba(255,255,255,0.1);
    }

    .dark body {
      background: #0f172a;
      color: #e2e8f0;
    }
    .dark h1, .dark h2, .dark h3 { color: #f1f5f9; }
    .dark a { color: #60a5fa; }
    .dark .page-header { border-bottom-color: #334155; }
    .dark code { background-color: #1e293b; color: #e2e8f0; }
    .dark pre {
      border: 1px solid #334155;
    }
    .dark blockquote {
      border-left-color: #334155;
      color: #94a3b8;
    }
    .dark th, .dark td { border-color: #334155; }
    .dark th { background: #1e293b; }
    .dark hr { border-top-color: #334155; }

    /* Copy Button */
    pre { position: relative; }
    .copy-button {
      position: absolute;
      top: 8px;
      right: 8px;
      padding: 4px 8px;
      font-size: 0.8rem;
      color: #94a3b8;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s, background 0.2s;
    }
    pre:hover .copy-button, .copy-button:focus {
      opacity: 1;
    }
    .copy-button:hover {
      background: rgba(255, 255, 255, 0.2);
      color: #e2e8f0;
    }

    .skip-link {
      position: absolute;
      top: -9999px;
      left: 0;
      background: #ffffff;
      padding: 8px;
      z-index: 1000;
      text-decoration: none;
      color: #2563eb;
      border: 1px solid #e5e7eb;
      border-radius: 0 0 6px 0;
    }
    .skip-link:focus {
      top: 0;
    }

  </style>
</head>
<body>
  <a href="#main-content" class="skip-link">Skip to main content</a>

  <div class="page-header">
    <a href="../../../../../hubs/causal-inference-index.html" class="back-link">‚Üê Back to Causal Inference</a>
    <button id="theme-toggle" class="theme-toggle" aria-label="Toggle Dark Mode">üåô</button>
  </div>
<main id="main-content" tabindex="-1">

<h1 id="topic-cross-fitting-and-orthogonalization">Topic: Cross-Fitting and Orthogonalization</h1>
<h2 id="1-formal-definition-what-is-it-and-how-can-we-use-it">1) Formal definition (what is it, and how can we use it?)</h2>
<p>Cross-fitting and orthogonalization are techniques used in causal inference to address <em>confounding</em> and <em>model selection bias</em> when estimating causal parameters, such as the average treatment effect (ATE). They help to obtain <em>consistent</em> and <em>asymptotically normal</em> estimators, even when nuisance functions (e.g., propensity scores, outcome models) are estimated using flexible machine learning methods.</p>
<p><strong>Orthogonalization (or Neyman Orthogonality)</strong> aims to construct an <em>estimating equation</em> whose solution yields the causal parameter of interest. Crucially, this estimating equation is <em>orthogonal</em> to nuisance parameters. This means that small errors in the estimation of the nuisance parameters (e.g., the propensity score) do not affect the asymptotic properties of the estimator for the causal parameter. Orthogonalization achieves this by cleverly manipulating the score function, such that the derivative of the estimating equation with respect to the nuisance parameters is zero (or has expectation zero).</p>
<p><strong>Cross-fitting</strong> is a technique used in conjunction with orthogonalization to further mitigate bias that arises from overfitting when using flexible machine learning algorithms to estimate the nuisance parameters. In cross-fitting, the data is split into K folds. For each fold, the nuisance parameters are estimated using the data from the <em>other</em> K-1 folds.  These estimates are then used to construct orthogonal scores for observations in the held-out fold. This ensures that the nuisance parameter estimates used to evaluate the orthogonal score for a given observation are "out-of-sample" and therefore less subject to overfitting bias.</p>
<p><strong>How can we use it?</strong></p>
<ol>
<li><strong>Identify the causal parameter of interest:</strong> Define the causal effect you want to estimate (e.g., ATE, ATT).</li>
<li><strong>Derive an orthogonal estimating equation:</strong>  This involves some mathematical derivation. The goal is to express the estimation problem in terms of a score function that is orthogonal to nuisance parameters.  The resulting estimating equation will typically involve integrals over the distribution of the data.  Because we only have a sample, we will replace those integrals with sample averages. The nuisance parameters that appear in this equation must be estimated using flexible ML models.</li>
<li><strong>Estimate nuisance parameters using machine learning:</strong> Employ machine learning algorithms to estimate the nuisance parameters (e.g., propensity score, outcome models).</li>
<li><strong>Implement cross-fitting:</strong> Split the data into folds, estimate the nuisance parameters in the out-of-sample fashion, and construct the orthogonal scores.</li>
<li><strong>Solve the estimating equation:</strong> Compute the causal parameter estimate by solving the estimating equation with the cross-fitted, orthogonal scores. This often involves taking the sample mean of the orthogonal score and solving for the causal parameter.</li>
<li><strong>Compute standard errors:</strong>  Because the estimator is asymptotically normal, you can estimate standard errors using the sample variance of the orthogonal score.</li>
</ol>
<h2 id="2-application-scenario">2) Application scenario</h2>
<p>A common application is estimating the Average Treatment Effect (ATE) in observational studies. Let's say we want to estimate the effect of a new drug (treatment) on patient recovery, but we only have observational data where patients themselves chose whether to take the drug.</p>
<p><strong>Scenario:</strong> We have data on patients, including their characteristics (age, gender, medical history), whether they took the drug (treatment indicator), and their recovery outcome.  Because the drug choice was not randomized, the treated and control groups are likely to differ systematically, leading to confounding.  We can use cross-fitting and orthogonalization to address this.</p>
<p><strong>Steps:</strong></p>
<ol>
<li><strong>Causal Parameter:</strong>  ATE = E[Y(1) - Y(0)], where Y(1) is the potential outcome under treatment and Y(0) is the potential outcome under control.</li>
<li>
<p><strong>Orthogonal Estimating Equation:</strong> A popular orthogonal score function for the ATE in this case is:</p>
<p><code>score(O; Œ∏) = D * (Y - Q(W, 1)) / e(W) - (1 - D) * (Y - Q(W, 0)) / (1 - e(W)) - (Q(W, 1) - Q(W, 0)) - Œ∏</code>
where:
*   O represents the observed data.
*   Œ∏ is the ATE.
*   D is the treatment indicator (1 if treated, 0 if control).
*   Y is the outcome.
*   Q(W, D) is the expected outcome given covariates W and treatment D (outcome model).
*   e(W) is the propensity score (probability of treatment given covariates W).</p>
<p>Solving E[score(O; Œ∏)] = 0 for Œ∏ gives us an estimate of the ATE.  Note that the "nuisance parameters" here are Q(W, D) and e(W), and they are estimated from the data.  The specific form of the score function makes it orthogonal; intuitively, errors in estimating the propensity score <code>e(W)</code> only affect the variance, but not the <em>bias</em>, of the ATE estimate (under some regularity conditions).</p>
</li>
<li>
<p><strong>Nuisance Parameter Estimation:</strong>  We estimate <code>Q(W, D)</code> and <code>e(W)</code> using machine learning models, like random forests or gradient boosting.</p>
</li>
<li><strong>Cross-fitting:</strong> Split the data into, say, 5 folds. For each fold <em>k</em>:<ul>
<li>Train the machine learning models for <code>Q(W, D)</code> and <code>e(W)</code> using the data from the other 4 folds.</li>
<li>Use these trained models to predict <code>Q(W, D)</code> and <code>e(W)</code> for the observations in fold <em>k</em>.</li>
<li>Calculate the orthogonal score for each observation in fold <em>k</em> using these out-of-sample predictions.</li>
</ul>
</li>
<li><strong>ATE Estimation:</strong> Average the orthogonal scores across all observations in all folds. The ATE estimate is the value of  Œ∏  that makes this average equal to zero (approximately).</li>
<li><strong>Standard Error Estimation:</strong> Calculate the sample variance of the orthogonal scores across all observations, and use this to construct a confidence interval for the ATE.</li>
</ol>
<h2 id="3-python-method-if-possible">3) Python method (if possible)</h2>
<pre class="codehilite"><code class="language-python">import numpy as np
from sklearn.model_selection import KFold
from sklearn.ensemble import RandomForestClassifier, RandomForestRegressor
from sklearn.linear_model import LinearRegression

def estimate_ate_cross_fit(treatment, outcome, covariates, n_folds=5):
    &quot;&quot;&quot;
    Estimates the Average Treatment Effect (ATE) using cross-fitting and
    an orthogonal score.

    Args:
        treatment: A numpy array of treatment indicators (1 for treated, 0 for control).
        outcome: A numpy array of outcomes.
        covariates: A numpy array of covariates.
        n_folds: The number of folds for cross-fitting.

    Returns:
        A tuple containing the ATE estimate and its standard error.
    &quot;&quot;&quot;

    n_samples = len(treatment)
    kf = KFold(n_splits=n_folds, shuffle=True, random_state=42)  # Ensure reproducibility

    propensity_scores = np.zeros(n_samples)
    outcome_predictions_treated = np.zeros(n_samples)
    outcome_predictions_control = np.zeros(n_samples)
    orthogonal_scores = np.zeros(n_samples)

    for train_index, test_index in kf.split(covariates):
        # Split data into train and test for this fold
        treatment_train, treatment_test = treatment[train_index], treatment[test_index]
        outcome_train, outcome_test = outcome[train_index], outcome[test_index]
        covariates_train, covariates_test = covariates[train_index], covariates[test_index]

        # 1. Estimate propensity score (probability of treatment)
        propensity_model = RandomForestClassifier(random_state=42) #Or another model
        propensity_model.fit(covariates_train, treatment_train)
        propensity_scores[test_index] = propensity_model.predict_proba(covariates_test)[:, 1]  # Probability of treatment

        # 2. Estimate outcome models (E[Y|W, D])
        #   - Outcome model for treated (D=1)
        outcome_model_treated = RandomForestRegressor(random_state=42) #Or another model
        outcome_model_treated.fit(covariates_train[treatment_train == 1], outcome_train[treatment_train == 1])
        outcome_predictions_treated[test_index] = outcome_model_treated.predict(covariates_test)

        #   - Outcome model for control (D=0)
        outcome_model_control = RandomForestRegressor(random_state=42) #Or another model
        outcome_model_control.fit(covariates_train[treatment_train == 0], outcome_train[treatment_train == 0])
        outcome_predictions_control[test_index] = outcome_model_control.predict(covariates_test)

        # 3. Calculate Orthogonal Score
        orthogonal_scores[test_index] = (
            treatment_test * (outcome_test - outcome_predictions_treated[test_index]) / propensity_scores[test_index]
            - (1 - treatment_test) * (outcome_test - outcome_predictions_control[test_index]) / (1 - propensity_scores[test_index])
            - (outcome_predictions_treated[test_index] - outcome_predictions_control[test_index])
        )

    # 4. Estimate ATE
    ate_estimate = np.mean(orthogonal_scores)

    # 5. Estimate Standard Error
    ate_std_error = np.std(orthogonal_scores) / np.sqrt(n_samples)

    return ate_estimate, ate_std_error

# Example usage:
np.random.seed(0) #Ensure reproducibility

n_samples = 200
covariates = np.random.rand(n_samples, 5) #Some simulated covariates
treatment = np.random.randint(0, 2, n_samples) #Simulated treatment
outcome = 2 * treatment + np.sum(covariates, axis=1) + np.random.randn(n_samples) #Simulated outcome

ate, se = estimate_ate_cross_fit(treatment, outcome, covariates)
print(f&quot;ATE Estimate: {ate:.3f}&quot;)
print(f&quot;Standard Error: {se:.3f}&quot;)
</code></pre>

<p><strong>Explanation:</strong></p>
<ul>
<li>The code implements the steps described in the application scenario.</li>
<li>It uses <code>sklearn</code> for machine learning models (Random Forest in this example, but other models can be used).</li>
<li><code>KFold</code> is used for cross-fitting.</li>
<li>The orthogonal score is calculated for each observation within each fold.</li>
<li>The ATE is estimated as the mean of the orthogonal scores.</li>
<li>The standard error is estimated using the sample variance of the scores.</li>
<li>A simple example shows how to use the function.</li>
</ul>
<p><strong>Important Considerations:</strong></p>
<ul>
<li><strong>Model Choice:</strong>  The choice of machine learning models for the propensity score and outcome models is crucial.  Consider using models that are flexible enough to capture complex relationships but also avoid overfitting.  Regularization is often helpful.</li>
<li><strong>Positivity/Overlap:</strong> Cross-fitting and Orthogonalization will still fail if the positivity/overlap assumption is violated.  The propensity score must be bounded away from 0 and 1 for all individuals in the sample.</li>
<li><strong>Regularity Conditions:</strong>  The theoretical guarantees of consistency and asymptotic normality rely on certain regularity conditions, such as smoothness of the nuisance functions and sufficient sample size.</li>
</ul>
<h2 id="4-follow-up-question">4) Follow-up question</h2>
<p>How does cross-fitting with orthogonalization relate to Double Machine Learning (DML) and Targeted Maximum Likelihood Estimation (TMLE)? What are the advantages/disadvantages of each?</p>
  </main>
  <script>
    const btn = document.getElementById('theme-toggle');
    const html = document.documentElement;
    
    function updateIcon() {
      btn.textContent = html.classList.contains('dark') ? '‚òÄÔ∏è' : 'üåô';
    }
    
    // Set initial icon
    updateIcon();

    btn.addEventListener('click', () => {
      if (html.classList.contains('dark')) {
        html.classList.remove('dark');
        localStorage.theme = 'light';
      } else {
        html.classList.add('dark');
        localStorage.theme = 'dark';
      }
      updateIcon();
    });

    // Copy Code Functionality
    document.querySelectorAll('pre').forEach(pre => {
      const button = document.createElement('button');
      button.className = 'copy-button';
      button.textContent = 'Copy';
      button.setAttribute('aria-label', 'Copy code to clipboard');

      pre.appendChild(button);

      button.addEventListener('click', async () => {
        const code = pre.querySelector('code');
        if (!code) return;

        try {
          await navigator.clipboard.writeText(code.innerText);
          button.textContent = 'Copied!';
          setTimeout(() => {
            button.textContent = 'Copy';
          }, 2000);
        } catch (err) {
          console.error('Failed to copy:', err);
          button.textContent = 'Error';
        }
      });
    });
  </script>
</body>
</html>
