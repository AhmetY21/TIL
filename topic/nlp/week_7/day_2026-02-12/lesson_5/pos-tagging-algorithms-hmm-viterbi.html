<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>POS Tagging Algorithms (HMM, Viterbi)</title>
  <script>
    if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  </script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.6;
      max-width: 900px;
      margin: 0 auto;
      padding: 24px;
      color: #111827;
      background: #ffffff;
    }
    h1, h2, h3 { color: #111827; }
    a { color: #2563eb; text-decoration: none; }
    a:hover { text-decoration: underline; }
    code { background-color: #f3f4f6; padding: 2px 6px; border-radius: 6px; }
    pre { background-color: #0b1020; color: #e5e7eb; padding: 16px; border-radius: 10px; overflow-x: auto; }
    pre code { background: transparent; padding: 0; }
    blockquote { border-left: 4px solid #e5e7eb; margin: 0; padding-left: 16px; color: #4b5563; }
    table { width: 100%; border-collapse: collapse; margin: 16px 0; }
    th, td { border: 1px solid #e5e7eb; padding: 8px; text-align: left; }
    th { background: #f9fafb; }
    hr { border: none; border-top: 1px solid #e5e7eb; margin: 24px 0; }

    .theme-toggle {
      position: absolute;
      top: 20px;
      right: 20px;
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      padding: 8px;
      border-radius: 50%;
      transition: background 0.2s;
    }
    .theme-toggle:hover {
      background: rgba(0,0,0,0.05);
    }
    .dark .theme-toggle:hover {
      background: rgba(255,255,255,0.1);
    }

    .dark body {
      background: #0f172a;
      color: #e2e8f0;
    }
    .dark h1, .dark h2, .dark h3 { color: #f1f5f9; }
    .dark a { color: #60a5fa; }
    .dark code { background-color: #1e293b; color: #e2e8f0; }
    .dark pre {
      border: 1px solid #334155;
    }
    .dark blockquote {
      border-left-color: #334155;
      color: #94a3b8;
    }
    .dark th, .dark td { border-color: #334155; }
    .dark th { background: #1e293b; }
    .dark hr { border-top-color: #334155; }
  </style>
</head>
<body>
  <button id="theme-toggle" class="theme-toggle" aria-label="Toggle Dark Mode">ðŸŒ™</button>
<h1 id="topic-pos-tagging-algorithms-hmm-viterbi">Topic: POS Tagging Algorithms (HMM, Viterbi)</h1>
<h2 id="1-formal-definition-what-is-it-and-how-can-we-use-it">1) Formal definition (what is it, and how can we use it?)</h2>
<p><strong>POS Tagging:</strong> Part-of-Speech (POS) tagging, also known as grammatical tagging or word-category disambiguation, is the process of assigning a part-of-speech (e.g., noun, verb, adjective, adverb) to each word in a text. This assignment is based on both the word's definition and its context within the sentence.</p>
<p><strong>Hidden Markov Model (HMM) for POS Tagging:</strong> An HMM is a probabilistic sequence model used to label each unit in a sequence of observations. In the context of POS tagging, the observed sequence is the sequence of words in a sentence, and the hidden sequence is the sequence of POS tags corresponding to those words.  The HMM model consists of:</p>
<ul>
<li><strong>States:</strong> The set of POS tags (e.g., Noun, Verb, Adjective).</li>
<li><strong>Observations:</strong> The sequence of words in the sentence.</li>
<li><strong>Transition Probabilities:</strong> The probability of transitioning from one POS tag to another POS tag (e.g., P(Verb | Noun) - the probability of a verb following a noun).  Formally, P(tag_i | tag_{i-1}).</li>
<li><strong>Emission Probabilities (Observation Likelihoods):</strong> The probability of a word being assigned a particular POS tag (e.g., P(run | Verb) - the probability of the word "run" being a verb). Formally, P(word_i | tag_i).</li>
<li><strong>Initial Probabilities:</strong>  The probability of starting a sentence with a specific POS tag (e.g., P(Noun) - the probability that the first word is a noun).</li>
</ul>
<p><strong>Viterbi Algorithm:</strong> The Viterbi algorithm is a dynamic programming algorithm used to find the most likely sequence of hidden states (POS tags in our case) given a sequence of observed events (words) and an HMM. It efficiently computes the path with the highest probability through all possible state sequences. It uses these calculations:</p>
<ol>
<li><strong>Initialization:</strong> Calculate the probability of each starting state.</li>
<li><strong>Recursion:</strong> Calculate the maximum probability of reaching each state at each time step, considering all possible previous states.  This involves multiplying the transition probability from the previous state to the current state, the emission probability of the current observation given the current state, and the maximum probability of reaching the previous state.</li>
<li><strong>Termination:</strong>  Find the state with the highest probability at the end of the sequence.</li>
<li><strong>Backtracking:</strong> Trace back through the sequence of states that led to the highest probability, thus reconstructing the most likely sequence of POS tags.</li>
</ol>
<p><strong>How can we use it?</strong></p>
<p>We can use HMMs and the Viterbi algorithm to:</p>
<ul>
<li>Automatically assign POS tags to text, which is crucial for many NLP tasks.</li>
<li>Improve the accuracy of downstream NLP applications like machine translation, information retrieval, and question answering.</li>
<li>Perform text analysis, such as identifying the dominant grammatical structures in a document or comparing the writing styles of different authors.</li>
<li>Assist in speech recognition by helping to distinguish between words that sound alike but have different POS tags and meanings.</li>
</ul>
<h2 id="2-application-scenario">2) Application scenario</h2>
<p><strong>Scenario:</strong> Imagine we want to build a system that extracts information about companies and their products from news articles.  To do this effectively, we need to identify the relationships between different words in a sentence.  For example, we might want to find sentences where a company name (a proper noun) is followed by a verb describing its actions.</p>
<p><strong>Application:</strong> We can use an HMM with the Viterbi algorithm to perform POS tagging on the news articles. By accurately tagging the words in each sentence, we can then easily identify proper nouns (company names) and verbs, and look for specific patterns like "<Company Name> <Verb>".  This allows us to automatically extract information about company activities from the text.</p>
<p><strong>Example:</strong></p>
<p>Consider the sentence: "Apple announced a new iPhone."</p>
<ol>
<li><strong>Input:</strong> The sequence of words: "Apple announced a new iPhone ."</li>
<li><strong>HMM &amp; Viterbi:</strong> The HMM (trained on a large corpus of tagged text) and the Viterbi algorithm would analyze the sentence.</li>
<li>
<p><strong>Output:</strong> The following POS tags:</p>
<ul>
<li>Apple: NNP (Proper Noun, singular)</li>
<li>announced: VBD (Verb, past tense)</li>
<li>a: DT (Determiner)</li>
<li>new: JJ (Adjective)</li>
<li>iPhone: NN (Noun, singular)</li>
<li>.: . (Punctuation)</li>
</ul>
</li>
</ol>
<p>Now, based on these tags, our information extraction system can identify "Apple" as a company and "announced" as a verb related to its activity, allowing it to extract the information that Apple announced something.</p>
<h2 id="3-python-method-if-possible">3) Python method (if possible)</h2>
<p>While implementing a full HMM and Viterbi algorithm from scratch can be involved, we can use existing libraries like <code>nltk</code> or <code>spaCy</code> to perform POS tagging.  Here's an example using <code>nltk</code> with a pre-trained tagger:</p>
<pre class="codehilite"><code class="language-python">import nltk

# Download necessary resources (if not already downloaded)
try:
    nltk.data.find(&quot;taggers/averaged_perceptron_tagger&quot;)
except LookupError:
    nltk.download(&quot;averaged_perceptron_tagger&quot;)
try:
    nltk.data.find(&quot;corpora/brown&quot;)
except LookupError:
    nltk.download(&quot;brown&quot;)

from nltk.tokenize import word_tokenize

def pos_tag_sentence(sentence):
  &quot;&quot;&quot;
  Performs POS tagging on a given sentence using nltk's averaged_perceptron_tagger.

  Args:
    sentence: The sentence to tag (string).

  Returns:
    A list of tuples, where each tuple contains a word and its POS tag.
  &quot;&quot;&quot;
  try:
      tokens = word_tokenize(sentence)  # Tokenize the sentence
      tagged_words = nltk.pos_tag(tokens)  # POS tag the tokens
      return tagged_words
  except LookupError:
        print(&quot;Error: Required NLTK resources not found.  Please run nltk.download('punkt') if this occurs for the first time&quot;)
        return None




# Example usage
sentence = &quot;Apple announced a new iPhone.&quot;
tagged_sentence = pos_tag_sentence(sentence)

if tagged_sentence:
    print(tagged_sentence) # Output: [('Apple', 'NNP'), ('announced', 'VBD'), ('a', 'DT'), ('new', 'JJ'), ('iPhone', 'NN'), ('.', '.')]
</code></pre>

<p><strong>Explanation:</strong></p>
<ol>
<li><strong>Import nltk:</strong> Imports the NLTK library.</li>
<li><strong>Download Resources:</strong> Downloads the necessary NLTK resources if they are not already present. <code>nltk.download()</code> provides access to various datasets and models. The <code>averaged_perceptron_tagger</code> is a pre-trained tagger that uses an averaged perceptron algorithm.  <code>punkt</code> is required for tokenization.</li>
<li><strong>Tokenization:</strong> Uses <code>word_tokenize</code> to split the sentence into individual words (tokens).</li>
<li><strong>POS Tagging:</strong> The <code>nltk.pos_tag()</code> function then applies the tagger to the tokens and returns a list of tuples, where each tuple contains a word and its corresponding POS tag.</li>
<li><strong>Output:</strong> Prints the tagged sentence, showing the POS tag assigned to each word.</li>
</ol>
<p>This example demonstrates how to use a pre-trained tagger in <code>nltk</code>. You can also train your own HMM-based POS tagger using NLTK, but that requires significantly more code and a labeled training corpus.</p>
<h2 id="4-follow-up-question">4) Follow-up question</h2>
<p>How would you handle unknown words (words not seen during training) when using an HMM for POS tagging? What techniques can be used to improve the accuracy of the POS tagger for these out-of-vocabulary words?</p>
  <script>
    const btn = document.getElementById('theme-toggle');
    const html = document.documentElement;
    
    function updateIcon() {
      btn.textContent = html.classList.contains('dark') ? 'â˜€ï¸' : 'ðŸŒ™';
    }
    
    // Set initial icon
    updateIcon();

    btn.addEventListener('click', () => {
      if (html.classList.contains('dark')) {
        html.classList.remove('dark');
        localStorage.theme = 'light';
      } else {
        html.classList.add('dark');
        localStorage.theme = 'dark';
      }
      updateIcon();
    });
  </script>
</body>
</html>
