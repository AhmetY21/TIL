<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Feature Engineering for Text Data</title>
  <script>
    if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  </script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.6;
      max-width: 900px;
      margin: 0 auto;
      padding: 24px;
      color: #111827;
      background: #ffffff;
    }
    h1, h2, h3 { color: #111827; }
    a { color: #2563eb; text-decoration: none; }
    a:hover { text-decoration: underline; }
    code { background-color: #f3f4f6; padding: 2px 6px; border-radius: 6px; }
    pre { background-color: #0b1020; color: #e5e7eb; padding: 16px; border-radius: 10px; overflow-x: auto; }
    pre code { background: transparent; padding: 0; }
    blockquote { border-left: 4px solid #e5e7eb; margin: 0; padding-left: 16px; color: #4b5563; }
    table { width: 100%; border-collapse: collapse; margin: 16px 0; }
    th, td { border: 1px solid #e5e7eb; padding: 8px; text-align: left; }
    th { background: #f9fafb; }
    hr { border: none; border-top: 1px solid #e5e7eb; margin: 24px 0; }

    .page-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid #e5e7eb;
    }
    .back-link {
      font-weight: 600;
      text-decoration: none;
    }
    .back-link:hover {
      text-decoration: underline;
    }

    .theme-toggle {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 1.5rem;
      padding: 8px;
      border-radius: 50%;
      transition: background 0.2s;
    }
    .theme-toggle:hover {
      background: rgba(0,0,0,0.05);
    }
    .dark .theme-toggle:hover {
      background: rgba(255,255,255,0.1);
    }

    .dark body {
      background: #0f172a;
      color: #e2e8f0;
    }
    .dark h1, .dark h2, .dark h3 { color: #f1f5f9; }
    .dark a { color: #60a5fa; }
    .dark .page-header { border-bottom-color: #334155; }
    .dark code { background-color: #1e293b; color: #e2e8f0; }
    .dark pre {
      border: 1px solid #334155;
    }
    .dark blockquote {
      border-left-color: #334155;
      color: #94a3b8;
    }
    .dark th, .dark td { border-color: #334155; }
    .dark th { background: #1e293b; }
    .dark hr { border-top-color: #334155; }

    /* Copy Button */
    pre { position: relative; }
    .copy-button {
      position: absolute;
      top: 8px;
      right: 8px;
      padding: 4px 8px;
      font-size: 0.8rem;
      color: #94a3b8;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s, background 0.2s;
    }
    pre:hover .copy-button, .copy-button:focus {
      opacity: 1;
    }
    .copy-button:hover {
      background: rgba(255, 255, 255, 0.2);
      color: #e2e8f0;
    }
  </style>
</head>
<body>

  <div class="page-header">
    <a href="../../../../../hubs/nlp-index.html" class="back-link">‚Üê Back to Natural Language Processing</a>
    <button id="theme-toggle" class="theme-toggle" aria-label="Toggle Dark Mode">üåô</button>
  </div>

<h1 id="topic-feature-engineering-for-text-data">Topic: Feature Engineering for Text Data</h1>
<h2 id="1-formal-definition-what-is-it-and-how-can-we-use-it">1) Formal definition (what is it, and how can we use it?)</h2>
<p>Feature engineering for text data is the process of transforming raw text into numerical features that machine learning models can understand and use. Raw text, in its unprocessed form, is not directly usable by most machine learning algorithms, which typically require numerical input. Feature engineering bridges this gap by extracting meaningful information from text and representing it as numerical data.</p>
<p>We can use feature engineering for text data in a variety of NLP tasks, including:</p>
<ul>
<li><strong>Text classification:</strong> Identifying the category or topic of a document (e.g., spam detection, sentiment analysis).</li>
<li><strong>Text clustering:</strong> Grouping similar documents together.</li>
<li><strong>Information retrieval:</strong> Finding relevant documents based on a user's query.</li>
<li><strong>Machine translation:</strong> Converting text from one language to another.</li>
<li><strong>Question answering:</strong> Providing answers to questions based on a given text.</li>
</ul>
<p>Essentially, feature engineering helps to capture the semantic meaning, syntactic structure, and stylistic characteristics of the text in a way that is understandable by a machine learning model. Common approaches include:</p>
<ul>
<li><strong>Bag-of-Words (BoW):</strong> Represents text as the collection of its words, disregarding grammar and word order, and counting the frequency of each word.</li>
<li><strong>TF-IDF (Term Frequency-Inverse Document Frequency):</strong> Weights words based on their frequency in a document and their inverse frequency across the entire corpus, giving higher weights to words that are important in a specific document but not common across all documents.</li>
<li><strong>N-grams:</strong> Sequences of <em>n</em> consecutive words, which capture some information about word order.</li>
<li><strong>Word Embeddings:</strong> Represent words as dense, low-dimensional vectors that capture semantic relationships between words (e.g., Word2Vec, GloVe, FastText).</li>
<li><strong>Character-level features:</strong> Using character n-grams or character frequencies to extract features, useful for handling noisy text or dealing with different languages.</li>
<li><strong>Syntactic features:</strong> Part-of-speech tagging, dependency parsing, and other syntactic analyses can be used to extract features about the grammatical structure of the text.</li>
</ul>
<h2 id="2-application-scenario">2) Application scenario</h2>
<p>Consider a sentiment analysis task where we want to predict whether a movie review is positive or negative. Raw text alone cannot be fed into a machine learning model.  We need to transform the text into numerical features.</p>
<p>Using Bag-of-Words, we could create a vocabulary of all the unique words in our corpus of movie reviews. Then, for each review, we would create a vector representing the frequency of each word in the vocabulary within that review.  A review like "This movie was great and amazing!" would result in a vector where the counts for "great" and "amazing" would be 1, and the counts for all other words would be based on their presence in the review. This vector then becomes the input to a classifier.</p>
<p>Alternatively, using TF-IDF, we could assign higher weights to words like "amazing" and "terrible" (assuming they are rare across all movie reviews but common in highly positive or negative reviews, respectively) compared to common words like "the" or "and."</p>
<p>Word embeddings offer an even more sophisticated approach.  Instead of counting word occurrences, we can represent each word with a pre-trained vector capturing its semantic meaning. We could then average the word embeddings of all words in a review to obtain a single vector representing the overall sentiment of the review.</p>
<h2 id="3-python-method-if-possible">3) Python method (if possible)</h2>
<p>Here's an example using scikit-learn to perform TF-IDF feature extraction:</p>
<pre class="codehilite"><code class="language-python">from sklearn.feature_extraction.text import TfidfVectorizer

# Sample documents
documents = [
    &quot;This is the first document.&quot;,
    &quot;This document is the second document.&quot;,
    &quot;And this is the third one.&quot;,
    &quot;Is this the first document?&quot;
]

# Create a TfidfVectorizer object
vectorizer = TfidfVectorizer()

# Fit the vectorizer to the documents and transform them into a TF-IDF matrix
tfidf_matrix = vectorizer.fit_transform(documents)

# Print the TF-IDF matrix
print(tfidf_matrix.toarray())

# Print the vocabulary
print(vectorizer.vocabulary_)
</code></pre>

<p>This code snippet first defines a list of documents.  Then, it creates a <code>TfidfVectorizer</code> object from scikit-learn. The <code>fit_transform</code> method learns the vocabulary from the documents and transforms them into a TF-IDF matrix.  <code>tfidf_matrix.toarray()</code> converts the sparse matrix to a dense numpy array for easier viewing. <code>vectorizer.vocabulary_</code> provides a dictionary mapping each word to its index in the TF-IDF matrix.</p>
<p>For word embeddings, libraries like Gensim or Hugging Face Transformers are commonly used.</p>
<h2 id="4-follow-up-question">4) Follow-up question</h2>
<p>How do you choose the <em>best</em> feature engineering technique for a particular text analysis task? What are some factors that influence this choice?</p>
  <script>
    const btn = document.getElementById('theme-toggle');
    const html = document.documentElement;
    
    function updateIcon() {
      btn.textContent = html.classList.contains('dark') ? '‚òÄÔ∏è' : 'üåô';
    }
    
    // Set initial icon
    updateIcon();

    btn.addEventListener('click', () => {
      if (html.classList.contains('dark')) {
        html.classList.remove('dark');
        localStorage.theme = 'light';
      } else {
        html.classList.add('dark');
        localStorage.theme = 'dark';
      }
      updateIcon();
    });

    // Copy Code Functionality
    document.querySelectorAll('pre').forEach(pre => {
      const button = document.createElement('button');
      button.className = 'copy-button';
      button.textContent = 'Copy';
      button.setAttribute('aria-label', 'Copy code to clipboard');

      pre.appendChild(button);

      button.addEventListener('click', async () => {
        const code = pre.querySelector('code');
        if (!code) return;

        try {
          await navigator.clipboard.writeText(code.innerText);
          button.textContent = 'Copied!';
          setTimeout(() => {
            button.textContent = 'Copy';
          }, 2000);
        } catch (err) {
          console.error('Failed to copy:', err);
          button.textContent = 'Error';
        }
      });
    });
  </script>
</body>
</html>
