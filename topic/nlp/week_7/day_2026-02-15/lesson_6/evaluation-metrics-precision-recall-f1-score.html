<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Evaluation Metrics: Precision, Recall, F1-Score</title>
  <script>
    if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  </script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.6;
      max-width: 900px;
      margin: 0 auto;
      padding: 24px;
      color: #111827;
      background: #ffffff;
    }
    h1, h2, h3 { color: #111827; }
    a { color: #2563eb; text-decoration: none; }
    a:hover { text-decoration: underline; }
    code { background-color: #f3f4f6; padding: 2px 6px; border-radius: 6px; }
    pre { background-color: #0b1020; color: #e5e7eb; padding: 16px; border-radius: 10px; overflow-x: auto; }
    pre code { background: transparent; padding: 0; }
    blockquote { border-left: 4px solid #e5e7eb; margin: 0; padding-left: 16px; color: #4b5563; }
    table { width: 100%; border-collapse: collapse; margin: 16px 0; }
    th, td { border: 1px solid #e5e7eb; padding: 8px; text-align: left; }
    th { background: #f9fafb; }
    hr { border: none; border-top: 1px solid #e5e7eb; margin: 24px 0; }

    .page-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid #e5e7eb;
    }
    .back-link {
      font-weight: 600;
      text-decoration: none;
    }
    .back-link:hover {
      text-decoration: underline;
    }

    .theme-toggle {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 1.5rem;
      padding: 8px;
      border-radius: 50%;
      transition: background 0.2s;
    }
    .theme-toggle:hover {
      background: rgba(0,0,0,0.05);
    }
    .dark .theme-toggle:hover {
      background: rgba(255,255,255,0.1);
    }

    .dark body {
      background: #0f172a;
      color: #e2e8f0;
    }
    .dark h1, .dark h2, .dark h3 { color: #f1f5f9; }
    .dark a { color: #60a5fa; }
    .dark .page-header { border-bottom-color: #334155; }
    .dark code { background-color: #1e293b; color: #e2e8f0; }
    .dark pre {
      border: 1px solid #334155;
    }
    .dark blockquote {
      border-left-color: #334155;
      color: #94a3b8;
    }
    .dark th, .dark td { border-color: #334155; }
    .dark th { background: #1e293b; }
    .dark hr { border-top-color: #334155; }

    /* Copy Button */
    pre { position: relative; }
    .copy-button {
      position: absolute;
      top: 8px;
      right: 8px;
      padding: 4px 8px;
      font-size: 0.8rem;
      color: #94a3b8;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s, background 0.2s;
    }
    pre:hover .copy-button, .copy-button:focus {
      opacity: 1;
    }
    .copy-button:hover {
      background: rgba(255, 255, 255, 0.2);
      color: #e2e8f0;
    }
  </style>
</head>
<body>

  <div class="page-header">
    <a href="../../../../../hubs/nlp-index.html" class="back-link">‚Üê Back to Natural Language Processing</a>
    <button id="theme-toggle" class="theme-toggle" aria-label="Toggle Dark Mode">üåô</button>
  </div>

<h1 id="topic-evaluation-metrics-precision-recall-f1-score">Topic: Evaluation Metrics: Precision, Recall, F1-Score</h1>
<h2 id="1-formal-definition-what-is-it-and-how-can-we-use-it">1) Formal definition (what is it, and how can we use it?)</h2>
<p>Precision, Recall, and F1-Score are evaluation metrics used to assess the performance of classification models, particularly in tasks like information retrieval, machine learning, and natural language processing. They are especially useful when dealing with imbalanced datasets where simply measuring accuracy can be misleading. These metrics focus on the performance of positive predictions (i.e., cases where the model predicts something belongs to a specific class, and we want to know how correct that prediction is).</p>
<p>Let's define the terms that form the basis of these metrics:</p>
<ul>
<li><strong>True Positives (TP):</strong> The number of instances correctly predicted as positive (belonging to the class).</li>
<li><strong>False Positives (FP):</strong> The number of instances incorrectly predicted as positive (not belonging to the class, but predicted as belonging to it). Also known as Type I error.</li>
<li><strong>False Negatives (FN):</strong> The number of instances incorrectly predicted as negative (belonging to the class, but predicted as <em>not</em> belonging to it). Also known as Type II error.</li>
<li><strong>True Negatives (TN):</strong> The number of instances correctly predicted as negative (not belonging to the class).</li>
</ul>
<p>Using these, we can define Precision, Recall, and F1-Score as follows:</p>
<ul>
<li>
<p><strong>Precision:</strong>  Measures the accuracy of positive predictions.  It answers the question: "Of all the instances the model <em>predicted</em> as positive, how many were actually positive?"</p>
<ul>
<li>Formula:  <code>Precision = TP / (TP + FP)</code></li>
</ul>
</li>
<li>
<p><strong>Recall:</strong> Measures the ability of the model to find all the positive instances.  It answers the question: "Of all the instances that <em>actually</em> belong to the positive class, how many did the model correctly identify?"</p>
<ul>
<li>Formula: <code>Recall = TP / (TP + FN)</code></li>
</ul>
</li>
<li>
<p><strong>F1-Score:</strong> The harmonic mean of precision and recall. It provides a single score that balances both precision and recall.  It's useful when you want to find a balance between the two.</p>
<ul>
<li>Formula: <code>F1-Score = 2 * (Precision * Recall) / (Precision + Recall)</code></li>
</ul>
</li>
</ul>
<p>We use these metrics to:</p>
<ul>
<li><strong>Evaluate model performance:</strong> Compare different models and choose the one that performs best for a given task, especially with imbalanced data.</li>
<li><strong>Tune model parameters:</strong> Adjust parameters to optimize for precision, recall, or a balance between the two, depending on the application.</li>
<li><strong>Understand model behavior:</strong> Diagnose issues like high false positives or false negatives, which can inform improvements to the model or data.</li>
</ul>
<h2 id="2-application-scenario">2) Application scenario</h2>
<p>Imagine you are building a spam email classifier.  The positive class is "spam", and the negative class is "not spam" (ham).</p>
<ul>
<li>
<p>A <em>high precision</em> means that when your classifier flags an email as spam, it's very likely to be actual spam.  A high precision is important if you <em>really</em> don't want to accidentally classify a legitimate email as spam (because that's very annoying for the user).  In this case, a false positive is worse than a false negative.</p>
</li>
<li>
<p>A <em>high recall</em> means that your classifier is good at catching most of the spam emails. A high recall is important if you <em>really</em> want to filter out as much spam as possible, even if it means occasionally misclassifying a legitimate email as spam. In this case, a false negative is worse than a false positive.</p>
</li>
<li>
<p>The <em>F1-score</em> provides a balance between precision and recall. If you want a classifier that performs well on both fronts (i.e., catches most spam without misclassifying too many legitimate emails), the F1-score is a good metric to optimize.</p>
</li>
</ul>
<p>Another scenario might be detecting a rare disease. In this case, a high recall is critical because missing a true case (false negative) is very detrimental.</p>
<h2 id="3-python-method-if-possible">3) Python method (if possible)</h2>
<p>The <code>sklearn.metrics</code> module in scikit-learn provides functions for calculating precision, recall, and F1-score.</p>
<pre class="codehilite"><code class="language-python">from sklearn.metrics import precision_score, recall_score, f1_score

# Example:
y_true = [0, 1, 0, 0, 1, 1, 0]  # Actual labels (0 = negative, 1 = positive)
y_pred = [0, 1, 1, 0, 0, 1, 0]  # Predicted labels

precision = precision_score(y_true, y_pred)
recall = recall_score(y_true, y_pred)
f1 = f1_score(y_true, y_pred)

print(f&quot;Precision: {precision}&quot;)
print(f&quot;Recall: {recall}&quot;)
print(f&quot;F1-Score: {f1}&quot;)

# Example using pos_label parameter (useful if the positive class is not '1')
y_true_string = ['no', 'yes', 'no', 'no', 'yes', 'yes', 'no']
y_pred_string = ['no', 'yes', 'yes', 'no', 'no', 'yes', 'no']

precision_yes = precision_score(y_true_string, y_pred_string, pos_label='yes')
recall_yes = recall_score(y_true_string, y_pred_string, pos_label='yes')
f1_yes = f1_score(y_true_string, y_pred_string, pos_label='yes')

print(f&quot;Precision (yes): {precision_yes}&quot;)
print(f&quot;Recall (yes): {recall_yes}&quot;)
print(f&quot;F1-Score (yes): {f1_yes}&quot;)


# Support for different averaging methods (useful for multi-class classification)
from sklearn.metrics import precision_score, recall_score, f1_score

y_true_multi = [0, 1, 2, 0, 1, 2]
y_pred_multi = [0, 2, 1, 0, 0, 1]

precision_micro = precision_score(y_true_multi, y_pred_multi, average='micro')
recall_micro = recall_score(y_true_multi, y_pred_multi, average='micro')
f1_micro = f1_score(y_true_multi, y_pred_multi, average='micro')

precision_macro = precision_score(y_true_multi, y_pred_multi, average='macro')
recall_macro = recall_score(y_true_multi, y_pred_multi, average='macro')
f1_macro = f1_score(y_true_multi, y_pred_multi, average='macro')

print(f&quot;Micro-averaged Precision: {precision_micro}&quot;)
print(f&quot;Micro-averaged Recall: {recall_micro}&quot;)
print(f&quot;Micro-averaged F1-Score: {f1_micro}&quot;)

print(f&quot;Macro-averaged Precision: {precision_macro}&quot;)
print(f&quot;Macro-averaged Recall: {recall_macro}&quot;)
print(f&quot;Macro-averaged F1-Score: {f1_macro}&quot;)
</code></pre>

<h2 id="4-follow-up-question">4) Follow-up question</h2>
<p>How are precision and recall related to the Receiver Operating Characteristic (ROC) curve and Area Under the Curve (AUC) score, and when would you prefer to use ROC/AUC over precision/recall/F1-score, or vice-versa?</p>
  <script>
    const btn = document.getElementById('theme-toggle');
    const html = document.documentElement;
    
    function updateIcon() {
      btn.textContent = html.classList.contains('dark') ? '‚òÄÔ∏è' : 'üåô';
    }
    
    // Set initial icon
    updateIcon();

    btn.addEventListener('click', () => {
      if (html.classList.contains('dark')) {
        html.classList.remove('dark');
        localStorage.theme = 'light';
      } else {
        html.classList.add('dark');
        localStorage.theme = 'dark';
      }
      updateIcon();
    });

    // Copy Code Functionality
    document.querySelectorAll('pre').forEach(pre => {
      const button = document.createElement('button');
      button.className = 'copy-button';
      button.textContent = 'Copy';
      button.setAttribute('aria-label', 'Copy code to clipboard');

      pre.appendChild(button);

      button.addEventListener('click', async () => {
        const code = pre.querySelector('code');
        if (!code) return;

        try {
          await navigator.clipboard.writeText(code.innerText);
          button.textContent = 'Copied!';
          setTimeout(() => {
            button.textContent = 'Copy';
          }, 2000);
        } catch (err) {
          console.error('Failed to copy:', err);
          button.textContent = 'Error';
        }
      });
    });
  </script>
</body>
</html>
