<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Prompt Engineering Best Practices</title>
  <script>
    if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  </script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.6;
      max-width: 900px;
      margin: 0 auto;
      padding: 24px;
      color: #111827;
      background: #ffffff;
    }
    h1, h2, h3 { color: #111827; }
    a { color: #2563eb; text-decoration: none; }
    a:hover { text-decoration: underline; }
    code { background-color: #f3f4f6; padding: 2px 6px; border-radius: 6px; }
    pre { background-color: #0b1020; color: #e5e7eb; padding: 16px; border-radius: 10px; overflow-x: auto; }
    pre code { background: transparent; padding: 0; }
    blockquote { border-left: 4px solid #e5e7eb; margin: 0; padding-left: 16px; color: #4b5563; }
    table { width: 100%; border-collapse: collapse; margin: 16px 0; }
    th, td { border: 1px solid #e5e7eb; padding: 8px; text-align: left; }
    th { background: #f9fafb; }
    hr { border: none; border-top: 1px solid #e5e7eb; margin: 24px 0; }

    .page-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid #e5e7eb;
    }
    .back-link {
      font-weight: 600;
      text-decoration: none;
    }
    .back-link:hover {
      text-decoration: underline;
    }

    .theme-toggle {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 1.5rem;
      padding: 8px;
      border-radius: 50%;
      transition: background 0.2s;
    }
    .theme-toggle:hover {
      background: rgba(0,0,0,0.05);
    }
    .dark .theme-toggle:hover {
      background: rgba(255,255,255,0.1);
    }

    .dark body {
      background: #0f172a;
      color: #e2e8f0;
    }
    .dark h1, .dark h2, .dark h3 { color: #f1f5f9; }
    .dark a { color: #60a5fa; }
    .dark .page-header { border-bottom-color: #334155; }
    .dark code { background-color: #1e293b; color: #e2e8f0; }
    .dark pre {
      border: 1px solid #334155;
    }
    .dark blockquote {
      border-left-color: #334155;
      color: #94a3b8;
    }
    .dark th, .dark td { border-color: #334155; }
    .dark th { background: #1e293b; }
    .dark hr { border-top-color: #334155; }

    /* Copy Button */
    pre { position: relative; }
    .copy-button {
      position: absolute;
      top: 8px;
      right: 8px;
      padding: 4px 8px;
      font-size: 0.8rem;
      color: #94a3b8;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s, background 0.2s;
    }
    pre:hover .copy-button, .copy-button:focus {
      opacity: 1;
    }
    .copy-button:hover {
      background: rgba(255, 255, 255, 0.2);
      color: #e2e8f0;
    }
  </style>
</head>
<body>

  <div class="page-header">
    <a href="../../../../../hubs/nlp-index.html" class="back-link">‚Üê Back to Natural Language Processing</a>
    <button id="theme-toggle" class="theme-toggle" aria-label="Toggle Dark Mode">üåô</button>
  </div>

<h1 id="topic-prompt-engineering-best-practices">Topic: Prompt Engineering Best Practices</h1>
<h2 id="1-formal-definition-what-is-it-and-how-can-we-use-it">1) Formal definition (what is it, and how can we use it?)</h2>
<p>Prompt engineering is the process of designing effective prompts to elicit desired responses from large language models (LLMs). It involves crafting specific, clear, and well-structured prompts to guide the model towards generating accurate, relevant, and high-quality outputs.</p>
<p>Instead of relying solely on the model's pre-trained knowledge, prompt engineering leverages human understanding of language and context to guide the model's reasoning and output.</p>
<p>We can use prompt engineering to:</p>
<ul>
<li><strong>Improve accuracy and relevance:</strong> By providing specific instructions and context, we can reduce ambiguity and steer the model towards the correct answer or desired output.</li>
<li><strong>Control the style and tone of the output:</strong> Prompts can be tailored to generate responses in a specific style (e.g., formal, informal, humorous) and tone (e.g., optimistic, critical).</li>
<li><strong>Guide the model's reasoning process:</strong> By breaking down complex tasks into smaller steps within the prompt, we can help the model reason more effectively and arrive at more accurate conclusions.</li>
<li><strong>Extract specific information:</strong> Prompts can be designed to extract specific information from a larger text, such as names, dates, or key concepts.</li>
<li><strong>Generate creative content:</strong> Prompts can be used to spark creativity and generate novel content, such as poems, stories, or scripts.</li>
</ul>
<p>Essentially, it's about turning vague queries into well-defined instructions for the LLM to execute effectively. Some core principles include being clear, specific, providing context, and using delimiters.</p>
<h2 id="2-application-scenario">2) Application scenario</h2>
<p>Let's say we want to use a large language model to summarize a news article. A naive approach might be to simply input the article text and ask for a summary. However, a well-engineered prompt can yield a much better result.</p>
<p><strong>Poor Prompt:</strong></p>
<p>"Summarize this article: [Article Text]"</p>
<p><strong>Well-Engineered Prompt:</strong></p>
<p>"You are a professional news editor. Summarize the following news article in no more than 150 words, focusing on the key events, actors, and their impact. Ensure the summary is objective and avoids personal opinions.
Article: [Article Text]"</p>
<p>In this scenario, the well-engineered prompt:</p>
<ul>
<li><strong>Defines the role of the model:</strong> "You are a professional news editor" gives the model a specific persona to adopt, influencing its writing style and focus.</li>
<li><strong>Sets constraints:</strong> "Summarize... in no more than 150 words" provides a length limit, ensuring conciseness.</li>
<li><strong>Highlights key information:</strong> "focusing on the key events, actors, and their impact" guides the model towards the most important aspects of the article.</li>
<li><strong>Specifies desired tone:</strong> "Ensure the summary is objective and avoids personal opinions" prevents the model from injecting bias.</li>
</ul>
<p>This example illustrates how prompt engineering can significantly improve the quality and relevance of the generated summary.</p>
<h2 id="3-python-method-if-possible">3) Python method (if possible)</h2>
<p>While prompt engineering is primarily a conceptual practice, we can demonstrate how to structure prompts effectively using Python. This example uses f-strings to build a prompt dynamically.</p>
<pre class="codehilite"><code class="language-python">def generate_summary_prompt(article_text, word_limit=150):
  &quot;&quot;&quot;
  Generates a prompt for summarizing a news article.

  Args:
    article_text: The text of the news article.
    word_limit: The maximum number of words for the summary.

  Returns:
    A string representing the prompt.
  &quot;&quot;&quot;

  prompt = f&quot;&quot;&quot;
  You are a professional news editor. Summarize the following news article in no more than {word_limit} words, focusing on the key events, actors, and their impact. Ensure the summary is objective and avoids personal opinions.
  Article: {article_text}
  &quot;&quot;&quot;
  return prompt

# Example usage:
article = &quot;The stock market crashed today, with the Dow Jones Industrial Average falling by 500 points. This was attributed to rising inflation and concerns about a potential recession. Key sectors affected include technology and energy...&quot;
prompt = generate_summary_prompt(article, word_limit=100)
print(prompt)

# In practice, you would then pass this prompt to a language model API.
# For example, using OpenAI's API:
# import openai
# openai.api_key = &quot;YOUR_API_KEY&quot;
# response = openai.Completion.create(engine=&quot;text-davinci-003&quot;, prompt=prompt, max_tokens=150)
# summary = response.choices[0].text.strip()
# print(summary)
</code></pre>

<p>This code snippet demonstrates:</p>
<ul>
<li><strong>Dynamic prompt generation:</strong>  The <code>generate_summary_prompt</code> function allows us to easily customize the prompt by changing the article text and word limit.</li>
<li><strong>Clear prompt structure:</strong> The f-string provides a clean and readable way to structure the prompt, making it easier to understand and modify.</li>
<li><strong>Integration with LLM API (example commented out):</strong> The commented-out code shows how you would typically use this prompt with an LLM API like OpenAI's.  You'd need an API key to make the actual call.</li>
</ul>
<p>This Python function is just a tool to help construct well-formed prompts, and the core of prompt engineering remains a design and conceptual task.</p>
<h2 id="4-follow-up-question">4) Follow-up question</h2>
<p>How does the concept of "few-shot learning" relate to prompt engineering, and what are some best practices for implementing few-shot learning within a prompt?</p>
  <script>
    const btn = document.getElementById('theme-toggle');
    const html = document.documentElement;
    
    function updateIcon() {
      btn.textContent = html.classList.contains('dark') ? '‚òÄÔ∏è' : 'üåô';
    }
    
    // Set initial icon
    updateIcon();

    btn.addEventListener('click', () => {
      if (html.classList.contains('dark')) {
        html.classList.remove('dark');
        localStorage.theme = 'light';
      } else {
        html.classList.add('dark');
        localStorage.theme = 'dark';
      }
      updateIcon();
    });

    // Copy Code Functionality
    document.querySelectorAll('pre').forEach(pre => {
      const button = document.createElement('button');
      button.className = 'copy-button';
      button.textContent = 'Copy';
      button.setAttribute('aria-label', 'Copy code to clipboard');

      pre.appendChild(button);

      button.addEventListener('click', async () => {
        const code = pre.querySelector('code');
        if (!code) return;

        try {
          await navigator.clipboard.writeText(code.innerText);
          button.textContent = 'Copied!';
          setTimeout(() => {
            button.textContent = 'Copy';
          }, 2000);
        } catch (err) {
          console.error('Failed to copy:', err);
          button.textContent = 'Error';
        }
      });
    });
  </script>
</body>
</html>
