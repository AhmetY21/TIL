<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LLM Hallucinations and Mitigation</title>
  <script>
    if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  </script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.6;
      max-width: 900px;
      margin: 0 auto;
      padding: 24px;
      color: #111827;
      background: #ffffff;
    }
    h1, h2, h3 { color: #111827; }
    a { color: #2563eb; text-decoration: none; }
    a:hover { text-decoration: underline; }
    code { background-color: #f3f4f6; padding: 2px 6px; border-radius: 6px; }
    pre { background-color: #0b1020; color: #e5e7eb; padding: 16px; border-radius: 10px; overflow-x: auto; }
    pre code { background: transparent; padding: 0; }
    blockquote { border-left: 4px solid #e5e7eb; margin: 0; padding-left: 16px; color: #4b5563; }
    table { width: 100%; border-collapse: collapse; margin: 16px 0; }
    th, td { border: 1px solid #e5e7eb; padding: 8px; text-align: left; }
    th { background: #f9fafb; }
    hr { border: none; border-top: 1px solid #e5e7eb; margin: 24px 0; }

    .page-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid #e5e7eb;
    }
    .back-link {
      font-weight: 600;
      text-decoration: none;
    }
    .back-link:hover {
      text-decoration: underline;
    }

    .theme-toggle {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 1.5rem;
      padding: 8px;
      border-radius: 50%;
      transition: background 0.2s;
    }
    .theme-toggle:hover {
      background: rgba(0,0,0,0.05);
    }
    .dark .theme-toggle:hover {
      background: rgba(255,255,255,0.1);
    }

    .dark body {
      background: #0f172a;
      color: #e2e8f0;
    }
    .dark h1, .dark h2, .dark h3 { color: #f1f5f9; }
    .dark a { color: #60a5fa; }
    .dark .page-header { border-bottom-color: #334155; }
    .dark code { background-color: #1e293b; color: #e2e8f0; }
    .dark pre {
      border: 1px solid #334155;
    }
    .dark blockquote {
      border-left-color: #334155;
      color: #94a3b8;
    }
    .dark th, .dark td { border-color: #334155; }
    .dark th { background: #1e293b; }
    .dark hr { border-top-color: #334155; }

    /* Copy Button */
    pre { position: relative; }
    .copy-button {
      position: absolute;
      top: 8px;
      right: 8px;
      padding: 4px 8px;
      font-size: 0.8rem;
      color: #94a3b8;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s, background 0.2s;
    }
    pre:hover .copy-button, .copy-button:focus {
      opacity: 1;
    }
    .copy-button:hover {
      background: rgba(255, 255, 255, 0.2);
      color: #e2e8f0;
    }
  </style>
</head>
<body>

  <div class="page-header">
    <a href="../../../../../hubs/nlp-index.html" class="back-link">‚Üê Back to Natural Language Processing</a>
    <button id="theme-toggle" class="theme-toggle" aria-label="Toggle Dark Mode">üåô</button>
  </div>

<h1 id="topic-llm-hallucinations-and-mitigation">Topic: LLM Hallucinations and Mitigation</h1>
<h2 id="1-formal-definition-what-is-it-and-how-can-we-use-it">1) Formal definition (what is it, and how can we use it?)</h2>
<p>LLM hallucinations, in the context of Natural Language Processing (NLP), refer to instances where a Large Language Model (LLM) generates content that is factually incorrect, nonsensical, or irrelevant to the given prompt, despite appearing coherent and confident. Essentially, it's when the LLM "makes things up." These fabrications can manifest as inventing facts, attributing false information to sources, creating non-existent concepts, or providing answers that are internally inconsistent or contradict widely accepted knowledge.</p>
<p>More formally, hallucinations can be categorized into two main types:</p>
<ul>
<li>
<p><strong>Factuality Hallucinations:</strong>  The LLM generates statements that directly contradict verifiable facts in the real world.  For example, "The capital of France is Berlin."</p>
</li>
<li>
<p><strong>Faithfulness Hallucinations:</strong> The LLM generates content that contradicts the source document it is supposed to be summarizing or answering questions about. This is particularly relevant in retrieval-augmented generation (RAG) setups. For example, if a document states "Company X increased revenue by 10%", the LLM hallucinates by stating "Company X decreased revenue by 5%."</p>
</li>
</ul>
<p>How can we use the <em>concept</em> of hallucinations?</p>
<ul>
<li><strong>Evaluating LLM Reliability:</strong> Identifying and quantifying the presence of hallucinations is crucial for assessing the trustworthiness and reliability of an LLM.</li>
<li><strong>Developing Mitigation Strategies:</strong>  Understanding the causes of hallucinations is the first step in developing methods to reduce their occurrence.</li>
<li><strong>Building Trustworthy AI Systems:</strong> By minimizing hallucinations, we can increase user confidence in LLM-powered applications across various domains.</li>
<li><strong>Identifying Model Limitations:</strong> Hallucinations highlight the inherent limitations of LLMs, particularly their reliance on statistical patterns rather than genuine understanding.</li>
<li><strong>Improving Prompt Engineering:</strong> Knowing that LLMs can hallucinate encourages more careful and precise prompt engineering to guide the model towards factual and relevant responses.</li>
</ul>
<h2 id="2-application-scenario">2) Application scenario</h2>
<p>Consider a customer service chatbot powered by an LLM. A user asks: "What is the return policy for the Acme Widget 3000?"</p>
<p>Without sufficient grounding in the correct documentation, the LLM might hallucinate the following response:</p>
<p>"For the Acme Widget 3000, you can return it within 60 days for a full refund, no questions asked. You'll also receive a free Acme Widget polishing cloth upon returning the product."</p>
<p>However, the <em>actual</em> return policy might be: 30 days for a refund, with a 15% restocking fee, and no mention of a polishing cloth.</p>
<p>In this scenario, the LLM is hallucinating a more lenient and attractive return policy, which could lead to:</p>
<ul>
<li><strong>Customer dissatisfaction:</strong>  The customer relies on the incorrect information and experiences frustration when the actual policy is different.</li>
<li><strong>Loss of trust:</strong> The customer loses trust in the chatbot and the company providing it.</li>
<li><strong>Operational issues:</strong>  The company's customer service team has to deal with complaints stemming from the inaccurate information provided by the chatbot.</li>
<li><strong>Legal liabilities:</strong> In certain regulated industries, providing incorrect information could lead to legal issues.</li>
</ul>
<p>This scenario highlights the importance of mitigating hallucinations, especially in applications that require accurate and reliable information. Retrieval-augmented generation (RAG) becomes crucial here, where the LLM is given access to the actual return policy document to inform its answer.</p>
<h2 id="3-python-method-if-possible">3) Python method (if possible)</h2>
<p>While there isn't a single "hallucination detector" function that works perfectly, we can use Python libraries and techniques to assess the <em>likelihood</em> of hallucinations, particularly in the context of RAG or summarization.  Here's an example using the <code>transformers</code> library to measure the consistency between a generated summary and the source document. This doesn't directly <em>detect</em> hallucinations but gives an indication of potential inaccuracies.</p>
<pre class="codehilite"><code class="language-python">from transformers import pipeline
from rouge import Rouge

def evaluate_summary_faithfulness(source_text, generated_summary):
    &quot;&quot;&quot;
    Evaluates the faithfulness of a generated summary to the source text using ROUGE scores.
    Higher ROUGE scores indicate better faithfulness.

    Args:
        source_text: The original text document.
        generated_summary: The summary generated by the LLM.

    Returns:
        A dictionary containing ROUGE scores.
    &quot;&quot;&quot;

    rouge = Rouge()
    try:
      scores = rouge.get_scores(generated_summary, source_text)[0] #rouge expects lists
      return scores
    except ValueError as e:
      print(f&quot;Error calculating ROUGE scores: {e}&quot;)
      return {&quot;rouge-1&quot;: {&quot;f&quot;: 0.0, &quot;p&quot;: 0.0, &quot;r&quot;: 0.0},
              &quot;rouge-2&quot;: {&quot;f&quot;: 0.0, &quot;p&quot;: 0.0, &quot;r&quot;: 0.0},
              &quot;rouge-l&quot;: {&quot;f&quot;: 0.0, &quot;p&quot;: 0.0, &quot;r&quot;: 0.0}}
    # Example Usage:
    source_text = &quot;The quick brown fox jumps over the lazy dog. The dog barks loudly.&quot;
    generated_summary = &quot;A fox jumps over a dog.&quot;
    rouge_scores = evaluate_summary_faithfulness(source_text, generated_summary)
    print(f&quot;ROUGE Scores: {rouge_scores}&quot;)


    source_text = &quot;Company X increased revenue by 10% in Q3. Profits also rose by 5%.&quot;
    hallucinated_summary = &quot;Company X decreased revenue by 5% in Q3 and increased profits by 20%&quot;
    rouge_scores_hallucinated = evaluate_summary_faithfulness(source_text, hallucinated_summary)
    print(f&quot;ROUGE Scores for Hallucinated Summary: {rouge_scores_hallucinated}&quot;)
</code></pre>

<p><strong>Explanation:</strong></p>
<ol>
<li><strong><code>evaluate_summary_faithfulness(source_text, generated_summary)</code>:</strong><ul>
<li>Takes the source text and the generated summary as input.</li>
<li>Uses the <code>Rouge</code> class from the <code>rouge</code> library to calculate ROUGE (Recall-Oriented Understudy for Gisting Evaluation) scores. ROUGE is a set of metrics commonly used to evaluate the quality of summaries. Higher ROUGE scores generally indicate better similarity between the summary and the source text, suggesting higher faithfulness and lower likelihood of hallucinations.</li>
<li>Calculates ROUGE-1, ROUGE-2, and ROUGE-L scores. These metrics measure the overlap of unigrams (ROUGE-1), bigrams (ROUGE-2), and the longest common subsequence (ROUGE-L) between the summary and the source text.</li>
<li>Returns a dictionary containing the ROUGE scores.</li>
<li>Includes error handling for potential issues during ROUGE score calculation.</li>
</ul>
</li>
</ol>
<p><strong>Limitations:</strong></p>
<ul>
<li>ROUGE scores don't directly detect hallucinations, but rather measure similarity. A hallucinated summary might still have high ROUGE scores if it uses similar wording to the source text while being factually incorrect.</li>
<li>This method is more applicable to summarization tasks or RAG-based question answering where you have a source document to compare against.</li>
<li>More sophisticated methods involve using dedicated hallucination detection models (which are still an active area of research).  These often involve knowledge graphs and fact verification techniques.</li>
</ul>
<h2 id="4-follow-up-question">4) Follow-up question</h2>
<p>Given that ROUGE scores, as demonstrated above, provide an imperfect measure of detecting hallucinations, what other metrics or techniques are being developed to more accurately identify and quantify LLM hallucinations, particularly in open-ended text generation scenarios where no direct source document is available?  Consider approaches that incorporate external knowledge sources or internal model consistency checks.</p>
  <script>
    const btn = document.getElementById('theme-toggle');
    const html = document.documentElement;
    
    function updateIcon() {
      btn.textContent = html.classList.contains('dark') ? '‚òÄÔ∏è' : 'üåô';
    }
    
    // Set initial icon
    updateIcon();

    btn.addEventListener('click', () => {
      if (html.classList.contains('dark')) {
        html.classList.remove('dark');
        localStorage.theme = 'light';
      } else {
        html.classList.add('dark');
        localStorage.theme = 'dark';
      }
      updateIcon();
    });

    // Copy Code Functionality
    document.querySelectorAll('pre').forEach(pre => {
      const button = document.createElement('button');
      button.className = 'copy-button';
      button.textContent = 'Copy';
      button.setAttribute('aria-label', 'Copy code to clipboard');

      pre.appendChild(button);

      button.addEventListener('click', async () => {
        const code = pre.querySelector('code');
        if (!code) return;

        try {
          await navigator.clipboard.writeText(code.innerText);
          button.textContent = 'Copied!';
          setTimeout(() => {
            button.textContent = 'Copy';
          }, 2000);
        } catch (err) {
          console.error('Failed to copy:', err);
          button.textContent = 'Error';
        }
      });
    });
  </script>
</body>
</html>
