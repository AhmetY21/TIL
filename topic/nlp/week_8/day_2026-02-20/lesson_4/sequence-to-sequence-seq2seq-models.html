<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Sequence-to-Sequence (Seq2Seq) Models</title>
  <script>
    if (localStorage.theme === 'dark' || (!('theme' in localStorage) && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
      document.documentElement.classList.add('dark');
    } else {
      document.documentElement.classList.remove('dark');
    }
  </script>
  <style>
    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      line-height: 1.6;
      max-width: 900px;
      margin: 0 auto;
      padding: 24px;
      color: #111827;
      background: #ffffff;
    }
    h1, h2, h3 { color: #111827; }
    a { color: #2563eb; text-decoration: none; }
    a:hover { text-decoration: underline; }
    code { background-color: #f3f4f6; padding: 2px 6px; border-radius: 6px; }
    pre { background-color: #0b1020; color: #e5e7eb; padding: 16px; border-radius: 10px; overflow-x: auto; }
    pre code { background: transparent; padding: 0; }
    blockquote { border-left: 4px solid #e5e7eb; margin: 0; padding-left: 16px; color: #4b5563; }
    table { width: 100%; border-collapse: collapse; margin: 16px 0; }
    th, td { border: 1px solid #e5e7eb; padding: 8px; text-align: left; }
    th { background: #f9fafb; }
    hr { border: none; border-top: 1px solid #e5e7eb; margin: 24px 0; }

    .page-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 24px;
      padding-bottom: 16px;
      border-bottom: 1px solid #e5e7eb;
    }
    .back-link {
      font-weight: 600;
      text-decoration: none;
    }
    .back-link:hover {
      text-decoration: underline;
    }

    .theme-toggle {
      background: none;
      border: none;
      cursor: pointer;
      font-size: 1.5rem;
      padding: 8px;
      border-radius: 50%;
      transition: background 0.2s;
    }
    .theme-toggle:hover {
      background: rgba(0,0,0,0.05);
    }

    /* Accessibility: Focus styles */
    a:focus-visible, button:focus-visible {
      outline: 2px solid #2563eb;
      outline-offset: 2px;
      border-radius: 4px;
    }
    .theme-toggle:focus-visible {
      border-radius: 50%;
    }

    .dark .theme-toggle:hover {

      background: rgba(255,255,255,0.1);
    }


    .dark a:focus-visible, .dark button:focus-visible {
      outline-color: #60a5fa;
    }

    .dark body {
      background: #0f172a;
      color: #e2e8f0;
    }
    .dark h1, .dark h2, .dark h3 { color: #f1f5f9; }
    .dark a { color: #60a5fa; }
    .dark .page-header { border-bottom-color: #334155; }
    .dark code { background-color: #1e293b; color: #e2e8f0; }
    .dark pre {
      border: 1px solid #334155;
    }
    .dark blockquote {
      border-left-color: #334155;
      color: #94a3b8;
    }
    .dark th, .dark td { border-color: #334155; }
    .dark th { background: #1e293b; }
    .dark hr { border-top-color: #334155; }

    /* Copy Button */
    pre { position: relative; }
    .copy-button {
      position: absolute;
      top: 8px;
      right: 8px;
      padding: 4px 8px;
      font-size: 0.8rem;
      color: #94a3b8;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 4px;
      cursor: pointer;
      opacity: 0;
      transition: opacity 0.2s, background 0.2s;
    }
    pre:hover .copy-button, .copy-button:focus {
      opacity: 1;
    }
    .copy-button:hover {
      background: rgba(255, 255, 255, 0.2);
      color: #e2e8f0;
    }
  </style>
</head>
<body>

  <div class="page-header">
    <a href="../../../../../hubs/nlp-index.html" class="back-link">‚Üê Back to Natural Language Processing</a>
    <button id="theme-toggle" class="theme-toggle" aria-label="Toggle Dark Mode">üåô</button>
  </div>

<h1 id="topic-sequence-to-sequence-seq2seq-models">Topic: Sequence-to-Sequence (Seq2Seq) Models</h1>
<h2 id="1-formal-definition-what-is-it-and-how-can-we-use-it">1) Formal definition (what is it, and how can we use it?)</h2>
<p>A Sequence-to-Sequence (Seq2Seq) model is a type of neural network architecture designed to transform an input sequence into an output sequence. Crucially, the input and output sequences can have different lengths.</p>
<p>Formally, a Seq2Seq model consists of two main components:</p>
<ul>
<li>
<p><strong>Encoder:</strong> The encoder takes the input sequence (e.g., "Hello, world!") and processes it to create a fixed-length vector representation called the "context vector" or "thought vector."  This vector aims to encapsulate the semantic meaning of the entire input sequence.  The encoder is typically an RNN (Recurrent Neural Network) like an LSTM (Long Short-Term Memory) or GRU (Gated Recurrent Unit).  The final hidden state of the encoder is often used as the context vector.</p>
</li>
<li>
<p><strong>Decoder:</strong> The decoder takes the context vector produced by the encoder as input and generates the output sequence (e.g., "Bonjour, le monde!").  The decoder is also typically an RNN (LSTM or GRU).  It starts by using the context vector as its initial hidden state.  Then, at each time step, it predicts the next token in the output sequence, conditioned on the previous token and its current hidden state. A special "start-of-sequence" token is often used as the initial input to the decoder, and a "end-of-sequence" token signals the end of the generated sequence.</p>
</li>
</ul>
<p>We can use Seq2Seq models for tasks where the input and output are both sequences but may have varying lengths, such as:</p>
<ul>
<li><strong>Machine Translation:</strong> Translating text from one language to another.</li>
<li><strong>Text Summarization:</strong> Generating a shorter version of a longer document.</li>
<li><strong>Chatbots:</strong> Generating responses to user input.</li>
<li><strong>Speech Recognition:</strong> Converting audio to text.</li>
<li><strong>Code Generation:</strong> Generating code from natural language descriptions.</li>
</ul>
<h2 id="2-application-scenario">2) Application scenario</h2>
<p>Consider the application scenario of <strong>machine translation</strong>.  We want to translate the English sentence "How are you?" to French.</p>
<ol>
<li>
<p><strong>Encoding:</strong> The encoder, say an LSTM, takes the sequence of English words "How", "are", "you", "?" (represented as numerical vectors, often using word embeddings) as input. It processes each word sequentially, updating its hidden state at each step. The final hidden state of the encoder becomes the context vector. This vector represents the meaning of the entire English sentence.</p>
</li>
<li>
<p><strong>Decoding:</strong> The decoder, also an LSTM, is initialized with the context vector from the encoder. It starts by generating the first word of the French translation, given the context vector and a "start-of-sequence" token. Let's say it predicts "Comment".</p>
</li>
<li>
<p><strong>Iteration:</strong> The decoder then takes "Comment" as input (again, as a numerical vector) and predicts the next word.  It might predict "allez-vous".</p>
</li>
<li>
<p><strong>Termination:</strong> The decoder continues generating words until it predicts an "end-of-sequence" token, indicating that the translation is complete. The final output sequence would be "Comment allez-vous ?".</p>
</li>
</ol>
<h2 id="3-python-method-if-possible">3) Python method (if possible)</h2>
<p>Using TensorFlow and Keras, we can create a simple Seq2Seq model.  This is a simplified example for demonstration purposes.  A real-world translation model would require much larger datasets and more sophisticated architectures (like attention mechanisms).</p>
<pre class="codehilite"><code class="language-python">import tensorflow as tf
from tensorflow import keras
from tensorflow.keras.layers import Input, LSTM, Dense

# Define the model
# Input sequence
encoder_inputs = Input(shape=(None, 100)) # Assuming each word is represented by a 100-dimensional vector

# Encoder LSTM
encoder_lstm = LSTM(256, return_state=True) # 256 units in the LSTM layer
encoder_outputs, state_h, state_c = encoder_lstm(encoder_inputs)

# Keep the states
encoder_states = [state_h, state_c]

# Decoder input
decoder_inputs = Input(shape=(None, 100))

# Decoder LSTM, using encoder states as initial state
decoder_lstm = LSTM(256, return_sequences=True, return_state=True)
decoder_outputs, _, _ = decoder_lstm(decoder_inputs, initial_state=encoder_states)

# Dense layer for output
decoder_dense = Dense(100, activation='softmax') # Assuming vocabulary size is 100
decoder_outputs = decoder_dense(decoder_outputs)

# Define the model
model = keras.Model([encoder_inputs, decoder_inputs], decoder_outputs)

# Compile the model
model.compile(optimizer='rmsprop', loss='categorical_crossentropy')

# Training data (dummy data for illustration - replace with actual data)
import numpy as np
encoder_input_data = np.random.rand(1000, 20, 100) # 1000 samples, sequence length 20, vector size 100
decoder_input_data = np.random.rand(1000, 20, 100)
decoder_target_data = np.random.rand(1000, 20, 100)

# Train the model
model.fit([encoder_input_data, decoder_input_data], decoder_target_data,
          batch_size=64,
          epochs=10)
</code></pre>

<p><strong>Explanation:</strong></p>
<ul>
<li><strong>Inputs:</strong> We define input layers for the encoder and decoder.  We assume that words are represented as 100-dimensional vectors (word embeddings).</li>
<li><strong>Encoder:</strong>  An LSTM is used to encode the input sequence.  <code>return_state=True</code> makes it return its hidden state (<code>state_h</code>) and cell state (<code>state_c</code>), which are used to initialize the decoder.</li>
<li><strong>Decoder:</strong>  Another LSTM decodes the sequence.  Crucially, <code>initial_state=encoder_states</code> initializes the decoder with the encoder's final states, thus passing the "context" information. <code>return_sequences=True</code> is important as we need the LSTM to output a sequence for each time step.</li>
<li><strong>Dense Layer:</strong> A dense (fully connected) layer is used to predict the next word in the sequence.  The <code>softmax</code> activation ensures that the output is a probability distribution over the vocabulary.  We are assuming a vocabulary size of 100 in this example.</li>
<li><strong>Model Definition:</strong> <code>keras.Model</code> connects the encoder and decoder to form the complete Seq2Seq model.</li>
<li><strong>Training:</strong>  The model is trained using <code>categorical_crossentropy</code> loss, which is suitable for multi-class classification problems (where each word in the vocabulary is a class). The example shows random data as placeholders, which must be replaced by actual data when training for translation.</li>
</ul>
<p><strong>Important Notes:</strong></p>
<ul>
<li>This is a basic example. Real-world translation models use more advanced techniques like attention mechanisms to improve performance.</li>
<li>The input and output data need to be preprocessed and vectorized (e.g., using word embeddings or one-hot encoding).</li>
<li>This example uses a fixed sequence length.  Padding or masking is often used to handle variable-length sequences.</li>
</ul>
<h2 id="4-follow-up-question">4) Follow-up question</h2>
<p>How does the "Attention Mechanism" improve upon the basic Seq2Seq model, and what problem does it address?</p>
  <script>
    const btn = document.getElementById('theme-toggle');
    const html = document.documentElement;
    
    function updateIcon() {
      btn.textContent = html.classList.contains('dark') ? '‚òÄÔ∏è' : 'üåô';
    }
    
    // Set initial icon
    updateIcon();

    btn.addEventListener('click', () => {
      if (html.classList.contains('dark')) {
        html.classList.remove('dark');
        localStorage.theme = 'light';
      } else {
        html.classList.add('dark');
        localStorage.theme = 'dark';
      }
      updateIcon();
    });

    // Copy Code Functionality
    document.querySelectorAll('pre').forEach(pre => {
      const button = document.createElement('button');
      button.className = 'copy-button';
      button.textContent = 'Copy';
      button.setAttribute('aria-label', 'Copy code to clipboard');

      pre.appendChild(button);

      button.addEventListener('click', async () => {
        const code = pre.querySelector('code');
        if (!code) return;

        try {
          await navigator.clipboard.writeText(code.innerText);
          button.textContent = 'Copied!';
          setTimeout(() => {
            button.textContent = 'Copy';
          }, 2000);
        } catch (err) {
          console.error('Failed to copy:', err);
          button.textContent = 'Error';
        }
      });
    });
  </script>
</body>
</html>
